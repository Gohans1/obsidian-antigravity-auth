/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => AntigravityAuthPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");

// src/types/index.ts
var DEFAULT_SETTINGS = {
  proxyPort: 8787,
  defaultModel: "antigravity-gemini-3-pro-high",
  autoStartProxy: true,
  enableLogging: false,
  maxRetries: 3,
  oauthClientId: "1071006060591-tmhssin2h21lcre235vtolojh4g403ep.apps.googleusercontent.com",
  oauthClientSecret: "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"
};
var OAUTH_CONFIG = {
  redirectPort: 51121,
  redirectPath: "/oauth-callback",
  scopes: [
    "https://www.googleapis.com/auth/cloud-platform",
    "https://www.googleapis.com/auth/userinfo.email",
    "https://www.googleapis.com/auth/userinfo.profile",
    "https://www.googleapis.com/auth/cclog",
    "https://www.googleapis.com/auth/experimentsandconfigs"
  ],
  authUrl: "https://accounts.google.com/o/oauth2/auth",
  tokenUrl: "https://oauth2.googleapis.com/token"
};
var ANTIGRAVITY_CONFIG = {
  endpoints: {
    daily: "https://daily-cloudcode-pa.sandbox.googleapis.com",
    autopush: "https://autopush-cloudcode-pa.sandbox.googleapis.com",
    prod: "https://cloudcode-pa.googleapis.com"
  },
  // Endpoint order for project discovery (prod first, then fallbacks)
  loadEndpoints: [
    "https://cloudcode-pa.googleapis.com",
    "https://daily-cloudcode-pa.sandbox.googleapis.com",
    "https://autopush-cloudcode-pa.sandbox.googleapis.com"
  ],
  paths: {
    generate: "/v1internal:generateContent",
    stream: "/v1internal:streamGenerateContent?alt=sse",
    loadCodeAssist: "/v1internal:loadCodeAssist"
  },
  userAgent: "antigravity/1.11.5 windows/amd64",
  apiClient: "google-cloud-sdk vscode_cloudshelleditor/0.1",
  // Default project ID when discovery fails (e.g., business/workspace accounts)
  defaultProjectId: "rising-fact-p41fc"
};
var AVAILABLE_MODELS = [
  { id: "antigravity-gemini-3-pro-high", name: "Gemini 3 Pro High", family: "gemini" },
  { id: "antigravity-gemini-3-pro-low", name: "Gemini 3 Pro Low", family: "gemini" },
  { id: "antigravity-gemini-3-flash", name: "Gemini 3 Flash", family: "gemini" },
  { id: "antigravity-claude-sonnet-4-5", name: "Claude Sonnet 4.5", family: "claude" },
  { id: "antigravity-claude-sonnet-4-5-thinking-low", name: "Claude Sonnet 4.5 Think Low", family: "claude" },
  { id: "antigravity-claude-sonnet-4-5-thinking-medium", name: "Claude Sonnet 4.5 Think Medium", family: "claude" },
  { id: "antigravity-claude-sonnet-4-5-thinking-high", name: "Claude Sonnet 4.5 Think High", family: "claude" },
  { id: "antigravity-claude-opus-4-5-thinking-low", name: "Claude Opus 4.5 Think Low", family: "claude" },
  { id: "antigravity-claude-opus-4-5-thinking-medium", name: "Claude Opus 4.5 Think Medium", family: "claude" },
  { id: "antigravity-claude-opus-4-5-thinking-high", name: "Claude Opus 4.5 Think High", family: "claude" }
];

// src/account/AccountManager.ts
var AccountManager = class {
  constructor(saveCallback, clientId, clientSecret) {
    this.saveCallback = saveCallback;
    this.accounts = /* @__PURE__ */ new Map();
    this.currentAccountEmail = null;
    this.refreshTimers = /* @__PURE__ */ new Map();
    this.clientId = clientId;
    this.clientSecret = clientSecret;
  }
  async loadAccounts(accounts) {
    this.accounts.clear();
    for (const account of accounts) {
      this.accounts.set(account.email, account);
      this.scheduleTokenRefresh(account);
    }
    if (accounts.length > 0 && !this.currentAccountEmail) {
      this.currentAccountEmail = accounts[0].email;
    }
  }
  addAccount(account) {
    this.accounts.set(account.email, account);
    if (!this.currentAccountEmail) {
      this.currentAccountEmail = account.email;
    }
    this.scheduleTokenRefresh(account);
    this.persistAccounts();
  }
  removeAccount(email) {
    const timer = this.refreshTimers.get(email);
    if (timer) {
      clearTimeout(timer);
      this.refreshTimers.delete(email);
    }
    this.accounts.delete(email);
    if (this.currentAccountEmail === email) {
      const remaining = Array.from(this.accounts.keys());
      this.currentAccountEmail = remaining.length > 0 ? remaining[0] : null;
    }
    this.persistAccounts();
  }
  getAccounts() {
    return Array.from(this.accounts.values());
  }
  getCurrentAccount() {
    if (!this.currentAccountEmail) return null;
    return this.accounts.get(this.currentAccountEmail) || null;
  }
  getActiveAccount() {
    const current = this.getCurrentAccount();
    if (current && current.status === "active" && !this.isRateLimited(current)) {
      return current;
    }
    for (const account of this.accounts.values()) {
      if (account.status === "active" && !this.isRateLimited(account)) {
        this.currentAccountEmail = account.email;
        return account;
      }
    }
    return null;
  }
  markRateLimited(email, durationMs) {
    const account = this.accounts.get(email);
    if (account) {
      account.status = "rate_limited";
      account.rateLimitExpiry = Date.now() + durationMs;
      this.persistAccounts();
    }
  }
  markActive(email) {
    const account = this.accounts.get(email);
    if (account) {
      account.status = "active";
      account.lastUsed = Date.now();
      delete account.rateLimitExpiry;
      this.persistAccounts();
    }
  }
  isRateLimited(account) {
    if (account.rateLimitExpiry && account.rateLimitExpiry > Date.now()) {
      return true;
    }
    if (account.rateLimitExpiry && account.rateLimitExpiry <= Date.now()) {
      account.status = "active";
      delete account.rateLimitExpiry;
    }
    return false;
  }
  rotateToNextAccount() {
    const accounts = Array.from(this.accounts.values());
    const currentIndex = accounts.findIndex((a) => a.email === this.currentAccountEmail);
    for (let i = 1; i <= accounts.length; i++) {
      const nextIndex = (currentIndex + i) % accounts.length;
      const candidate = accounts[nextIndex];
      if (candidate.status === "active" && !this.isRateLimited(candidate)) {
        this.currentAccountEmail = candidate.email;
        return candidate;
      }
    }
    return null;
  }
  scheduleTokenRefresh(account) {
    const existingTimer = this.refreshTimers.get(account.email);
    if (existingTimer) {
      clearTimeout(existingTimer);
    }
    const refreshIn = Math.max(0, account.expiresAt - Date.now() - 5 * 60 * 1e3);
    const timer = setTimeout(() => this.refreshToken(account.email), refreshIn);
    this.refreshTimers.set(account.email, timer);
  }
  async refreshToken(email) {
    const account = this.accounts.get(email);
    if (!account) return false;
    try {
      const response = await fetch(OAUTH_CONFIG.tokenUrl, {
        method: "POST",
        headers: { "Content-Type": "application/x-www-form-urlencoded" },
        body: new URLSearchParams({
          client_id: this.clientId,
          client_secret: this.clientSecret,
          refresh_token: account.refreshToken,
          grant_type: "refresh_token"
        })
      });
      if (!response.ok) {
        account.status = "expired";
        this.persistAccounts();
        return false;
      }
      const data = await response.json();
      account.accessToken = data.access_token;
      account.expiresAt = Date.now() + data.expires_in * 1e3;
      account.status = "active";
      this.scheduleTokenRefresh(account);
      this.persistAccounts();
      return true;
    } catch (error) {
      console.error("Token refresh failed:", error);
      account.status = "error";
      this.persistAccounts();
      return false;
    }
  }
  async persistAccounts() {
    await this.saveCallback(this.getAccounts());
  }
  dispose() {
    for (const timer of this.refreshTimers.values()) {
      clearTimeout(timer);
    }
    this.refreshTimers.clear();
  }
};

// src/auth/OAuthManager.ts
var http = __toESM(require("http"));
var crypto = __toESM(require("crypto"));
var OAuthManager = class {
  constructor(clientId, clientSecret) {
    this.server = null;
    this.codeVerifier = "";
    this.state = "";
    this.clientId = clientId;
    this.clientSecret = clientSecret;
  }
  generatePKCE() {
    this.codeVerifier = this.base64URLEncode(crypto.randomBytes(32));
    const hash = crypto.createHash("sha256").update(this.codeVerifier).digest();
    const codeChallenge = this.base64URLEncode(hash);
    return { codeVerifier: this.codeVerifier, codeChallenge };
  }
  base64URLEncode(buffer) {
    return buffer.toString("base64").replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
  }
  getAuthUrl() {
    this.state = crypto.randomBytes(16).toString("hex");
    const { codeChallenge } = this.generatePKCE();
    const params = new URLSearchParams({
      client_id: this.clientId,
      redirect_uri: `http://localhost:${OAUTH_CONFIG.redirectPort}${OAUTH_CONFIG.redirectPath}`,
      response_type: "code",
      scope: OAUTH_CONFIG.scopes.join(" "),
      access_type: "offline",
      prompt: "consent",
      code_challenge: codeChallenge,
      code_challenge_method: "S256",
      state: this.state
    });
    return `${OAUTH_CONFIG.authUrl}?${params.toString()}`;
  }
  async startCallbackServer() {
    this.stopCallbackServer();
    return new Promise((resolve, reject) => {
      this.server = http.createServer((req, res) => {
        const url = new URL(req.url || "", `http://localhost:${OAUTH_CONFIG.redirectPort}`);
        if (url.pathname !== OAUTH_CONFIG.redirectPath) {
          res.writeHead(404);
          res.end("Not found");
          return;
        }
        const code = url.searchParams.get("code");
        const state = url.searchParams.get("state");
        const error = url.searchParams.get("error");
        res.writeHead(200, { "Content-Type": "text/html" });
        res.end(`
          <!DOCTYPE html>
          <html>
          <head><title>Authentication Complete</title></head>
          <body style="font-family: sans-serif; text-align: center; padding: 50px;">
            <h1>${error ? "Authentication Failed" : "Authentication Successful!"}</h1>
            <p>${error ? error : "You can close this window and return to Obsidian."}</p>
            <script>setTimeout(() => window.close(), 3000);</script>
          </body>
          </html>
        `);
        this.stopCallbackServer();
        if (error) {
          reject(new Error(`OAuth error: ${error}`));
        } else if (code && state) {
          resolve({ code, state });
        } else {
          reject(new Error("Invalid OAuth callback"));
        }
      });
      this.server.on("error", (err) => {
        if (err.code === "EADDRINUSE") {
          reject(new Error(`Port ${OAUTH_CONFIG.redirectPort} is already in use. Please restart Obsidian or wait a moment and try again.`));
        } else {
          reject(new Error(`Server error: ${err.message}`));
        }
      });
      this.server.listen(OAUTH_CONFIG.redirectPort, "127.0.0.1", () => {
        console.log(`OAuth callback server listening on port ${OAUTH_CONFIG.redirectPort}`);
      });
      setTimeout(() => {
        if (this.server) {
          this.stopCallbackServer();
          reject(new Error("OAuth timeout"));
        }
      }, 5 * 60 * 1e3);
    });
  }
  stopCallbackServer() {
    if (this.server) {
      this.server.close();
      this.server = null;
    }
  }
  async exchangeCodeForTokens(code) {
    const response = await fetch(OAUTH_CONFIG.tokenUrl, {
      method: "POST",
      headers: { "Content-Type": "application/x-www-form-urlencoded" },
      body: new URLSearchParams({
        client_id: this.clientId,
        client_secret: this.clientSecret,
        code,
        code_verifier: this.codeVerifier,
        grant_type: "authorization_code",
        redirect_uri: `http://localhost:${OAUTH_CONFIG.redirectPort}${OAUTH_CONFIG.redirectPath}`
      })
    });
    if (!response.ok) {
      const error = await response.text();
      throw new Error(`Token exchange failed: ${error}`);
    }
    const data = await response.json();
    return {
      accessToken: data.access_token,
      refreshToken: data.refresh_token,
      expiresIn: data.expires_in
    };
  }
  async getUserInfo(accessToken) {
    const response = await fetch("https://www.googleapis.com/oauth2/v2/userinfo", {
      headers: { Authorization: `Bearer ${accessToken}` }
    });
    if (!response.ok) {
      throw new Error("Failed to get user info");
    }
    const data = await response.json();
    return { email: data.email };
  }
  async discoverProject(accessToken) {
    for (const endpoint of ANTIGRAVITY_CONFIG.loadEndpoints) {
      try {
        console.log(`Trying project discovery on ${endpoint}...`);
        const response = await fetch(`${endpoint}${ANTIGRAVITY_CONFIG.paths.loadCodeAssist}`, {
          method: "POST",
          headers: {
            "Authorization": `Bearer ${accessToken}`,
            "Content-Type": "application/json",
            "User-Agent": ANTIGRAVITY_CONFIG.userAgent,
            "X-Goog-Api-Client": ANTIGRAVITY_CONFIG.apiClient
          },
          body: JSON.stringify({})
        });
        if (!response.ok) {
          console.log(`Endpoint ${endpoint} returned ${response.status}, trying next...`);
          continue;
        }
        const data = await response.json();
        console.log("Project discovery response:", JSON.stringify(data));
        if (data.cloudAICompanionProject || data.cloudaicompanionProject) {
          const projectField = data.cloudAICompanionProject || data.cloudaicompanionProject;
          const match = projectField.match(/projects\/([^\/]+)/);
          if (match) {
            console.log(`Discovered project ID (from path): ${match[1]}`);
            return match[1];
          }
          console.log(`Discovered project ID (direct): ${projectField}`);
          return projectField;
        }
        if (data.managedProject) {
          const match = data.managedProject.match(/projects\/([^\/]+)/);
          if (match) {
            console.log(`Discovered managed project ID: ${match[1]}`);
            return match[1];
          }
          console.log(`Discovered managed project ID (direct): ${data.managedProject}`);
          return data.managedProject;
        }
      } catch (error) {
        console.log(`Endpoint ${endpoint} failed:`, error);
        continue;
      }
    }
    console.log(`Project discovery failed on all endpoints, using default: ${ANTIGRAVITY_CONFIG.defaultProjectId}`);
    return ANTIGRAVITY_CONFIG.defaultProjectId;
  }
  async performFullLogin() {
    const callbackPromise = this.startCallbackServer();
    const authUrl = this.getAuthUrl();
    require("electron").shell.openExternal(authUrl);
    const { code, state } = await callbackPromise;
    if (state !== this.state) {
      throw new Error("Invalid OAuth state");
    }
    const tokens = await this.exchangeCodeForTokens(code);
    const userInfo = await this.getUserInfo(tokens.accessToken);
    const projectId = await this.discoverProject(tokens.accessToken);
    return {
      email: userInfo.email,
      accessToken: tokens.accessToken,
      refreshToken: tokens.refreshToken,
      expiresAt: Date.now() + tokens.expiresIn * 1e3,
      projectId,
      status: "active",
      lastUsed: Date.now()
    };
  }
};

// src/proxy/ProxyServer.ts
var http2 = __toESM(require("http"));
var https = __toESM(require("https"));

// src/account/ResilienceEngine.ts
var ResilienceEngine = class {
  constructor(accountManager, maxRetries = 3) {
    this.accountManager = accountManager;
    this.maxRetries = maxRetries;
  }
  async executeWithRetry(requestFn) {
    let lastError;
    let attemptCount = 0;
    while (attemptCount < this.maxRetries) {
      const account = this.accountManager.getActiveAccount();
      if (!account) {
        return {
          success: false,
          error: new Error("No active accounts available"),
          statusCode: 429
        };
      }
      attemptCount++;
      try {
        const result = await requestFn(account);
        if (result.success) {
          this.accountManager.markActive(account.email);
          return result;
        }
        if (result.statusCode === 429) {
          const retryAfter = result.retryAfter || 6e4;
          console.log(`Rate limited on ${account.email}, retrying after ${retryAfter}ms`);
          this.accountManager.markRateLimited(account.email, retryAfter);
          const nextAccount = this.accountManager.rotateToNextAccount();
          if (!nextAccount) {
            return {
              success: false,
              error: new Error("All accounts are rate limited"),
              statusCode: 429,
              retryAfter
            };
          }
          continue;
        }
        if (result.statusCode && result.statusCode >= 400 && result.statusCode < 500) {
          return result;
        }
        lastError = result.error;
      } catch (error) {
        lastError = error;
        console.error(`Request failed on attempt ${attemptCount}:`, error);
      }
    }
    return {
      success: false,
      error: lastError || new Error("Max retries exceeded"),
      statusCode: 500
    };
  }
  parseRetryAfter(errorMessage) {
    const match = errorMessage.match(/reset after (\d+(?:\.\d+)?)(s|ms)/);
    if (match) {
      const value = parseFloat(match[1]);
      const unit = match[2];
      return unit === "ms" ? value : value * 1e3;
    }
    return 6e4;
  }
};

// src/transform/RequestTransformer.ts
var RequestTransformer = class {
  transformToAntigravity(openAIRequest, projectId) {
    var _a, _b;
    const modelId = this.mapModelId(openAIRequest.model);
    const { contents, systemInstruction } = this.transformMessages(openAIRequest.messages);
    const request2 = {
      project: projectId,
      model: modelId,
      request: {
        contents,
        generationConfig: {
          maxOutputTokens: openAIRequest.max_tokens || 8192,
          temperature: (_a = openAIRequest.temperature) != null ? _a : 0.7,
          topP: (_b = openAIRequest.top_p) != null ? _b : 0.95
        }
      },
      userAgent: "antigravity",
      requestId: this.generateRequestId()
    };
    if (systemInstruction) {
      request2.request.systemInstruction = systemInstruction;
    }
    if (modelId.includes("thinking")) {
      const thinkingBudget = this.getThinkingBudget(modelId);
      request2.request.generationConfig.thinkingConfig = {
        thinkingBudget,
        includeThoughts: true
      };
      if (request2.request.generationConfig.maxOutputTokens <= thinkingBudget) {
        request2.request.generationConfig.maxOutputTokens = thinkingBudget + 4e3;
      }
    }
    return request2;
  }
  mapModelId(openAIModel) {
    const modelId = openAIModel.replace("antigravity-", "");
    const modelMap = {
      "gemini-3-pro-high": "gemini-3-pro-high",
      "gemini-3-pro-low": "gemini-3-pro-low",
      "gemini-3-flash": "gemini-3-flash",
      "claude-sonnet-4-5": "claude-sonnet-4-5",
      "claude-sonnet-4-5-thinking-low": "claude-sonnet-4-5-thinking",
      "claude-sonnet-4-5-thinking-medium": "claude-sonnet-4-5-thinking",
      "claude-sonnet-4-5-thinking-high": "claude-sonnet-4-5-thinking",
      "claude-opus-4-5-thinking-low": "claude-opus-4-5-thinking",
      "claude-opus-4-5-thinking-medium": "claude-opus-4-5-thinking",
      "claude-opus-4-5-thinking-high": "claude-opus-4-5-thinking"
    };
    return modelMap[modelId] || modelId;
  }
  getThinkingBudget(modelId) {
    if (modelId.includes("low")) return 8e3;
    if (modelId.includes("medium")) return 16e3;
    if (modelId.includes("high")) return 32e3;
    return 16e3;
  }
  transformMessages(messages) {
    const contents = [];
    let systemInstruction;
    for (const msg of messages) {
      const textContent = this.extractTextContent(msg.content);
      if (msg.role === "system") {
        systemInstruction = {
          parts: [{ text: textContent }]
        };
      } else {
        const role = msg.role === "assistant" ? "model" : "user";
        contents.push({
          role,
          parts: [{ text: textContent }]
        });
      }
    }
    return { contents, systemInstruction };
  }
  extractTextContent(content) {
    if (typeof content === "string") {
      return content;
    }
    if (Array.isArray(content)) {
      const textParts = [];
      for (const part of content) {
        if (typeof part === "string") {
          textParts.push(part);
        } else if (part && typeof part === "object") {
          if (part.type === "text" && part.text) {
            textParts.push(part.text);
          } else if (part.text) {
            textParts.push(part.text);
          }
        }
      }
      return textParts.join("\n");
    }
    if (content && typeof content === "object" && content.text) {
      return content.text;
    }
    return String(content || "");
  }
  generateRequestId() {
    const bytes = new Uint8Array(16);
    globalThis.crypto.getRandomValues(bytes);
    bytes[6] = bytes[6] & 15 | 64;
    bytes[8] = bytes[8] & 63 | 128;
    const hex = Array.from(bytes).map((b) => b.toString(16).padStart(2, "0")).join("");
    return `agent-${hex.slice(0, 8)}-${hex.slice(8, 12)}-${hex.slice(12, 16)}-${hex.slice(16, 20)}-${hex.slice(20)}`;
  }
  getHeaders(accessToken, isStreaming = false) {
    const headers = {
      "Authorization": `Bearer ${accessToken}`,
      "Content-Type": "application/json",
      "User-Agent": ANTIGRAVITY_CONFIG.userAgent,
      "X-Goog-Api-Client": ANTIGRAVITY_CONFIG.apiClient,
      "Client-Metadata": JSON.stringify({
        ideType: "IDE_UNSPECIFIED",
        platform: "PLATFORM_UNSPECIFIED",
        pluginType: "GEMINI"
      })
    };
    if (isStreaming) {
      headers["Accept"] = "text/event-stream";
    }
    return headers;
  }
};

// src/transform/ResponseTransformer.ts
var ResponseTransformer = class {
  transformFromAntigravity(response, model) {
    var _a, _b;
    const candidate = response.response.candidates[0];
    const textParts = ((_b = (_a = candidate == null ? void 0 : candidate.content) == null ? void 0 : _a.parts) == null ? void 0 : _b.filter((p) => p.text)) || [];
    const text = textParts.map((p) => p.text).join("");
    return {
      id: response.response.responseId || this.generateId(),
      object: "chat.completion",
      created: Math.floor(Date.now() / 1e3),
      model,
      choices: [{
        index: 0,
        message: {
          role: "assistant",
          content: text
        },
        finish_reason: this.mapFinishReason(candidate == null ? void 0 : candidate.finishReason)
      }],
      usage: response.response.usageMetadata ? {
        prompt_tokens: response.response.usageMetadata.promptTokenCount,
        completion_tokens: response.response.usageMetadata.candidatesTokenCount,
        total_tokens: response.response.usageMetadata.totalTokenCount
      } : void 0
    };
  }
  transformStreamChunk(data, model, index) {
    var _a, _b, _c, _d, _e;
    try {
      const jsonStr = data.replace(/^data:\s*/, "").trim();
      if (!jsonStr || jsonStr === "[DONE]") return null;
      const response = JSON.parse(jsonStr);
      const candidate = (_b = (_a = response.response) == null ? void 0 : _a.candidates) == null ? void 0 : _b[0];
      if (!candidate) return null;
      const textParts = ((_d = (_c = candidate.content) == null ? void 0 : _c.parts) == null ? void 0 : _d.filter((p) => p.text && !p.thought)) || [];
      const text = textParts.map((p) => p.text).join("");
      return {
        id: ((_e = response.response) == null ? void 0 : _e.responseId) || this.generateId(),
        object: "chat.completion.chunk",
        created: Math.floor(Date.now() / 1e3),
        model,
        choices: [{
          index: 0,
          delta: {
            ...index === 0 ? { role: "assistant" } : {},
            ...text ? { content: text } : {}
          },
          finish_reason: candidate.finishReason === "STOP" ? "stop" : null
        }]
      };
    } catch (e) {
      console.error("Failed to parse stream chunk:", e);
      return null;
    }
  }
  formatSSEChunk(chunk) {
    return `data: ${JSON.stringify(chunk)}

`;
  }
  formatSSEDone() {
    return "data: [DONE]\n\n";
  }
  mapFinishReason(reason) {
    switch (reason) {
      case "STOP":
        return "stop";
      case "MAX_TOKENS":
        return "length";
      default:
        return null;
    }
  }
  generateId() {
    return `chatcmpl-${Date.now().toString(36)}${Math.random().toString(36).substr(2, 9)}`;
  }
};

// src/proxy/ProxyServer.ts
var ProxyServer = class {
  constructor(accountManager, port = 8787) {
    this.accountManager = accountManager;
    this.port = port;
    this.server = null;
    this.requestTransformer = new RequestTransformer();
    this.responseTransformer = new ResponseTransformer();
    this.resilienceEngine = new ResilienceEngine(accountManager);
  }
  async start() {
    return new Promise((resolve, reject) => {
      this.server = http2.createServer((req, res) => {
        this.handleRequest(req, res).catch((err) => {
          console.error("Request handler error:", err);
          this.sendError(res, 500, "Internal server error");
        });
      });
      this.server.on("error", (err) => {
        if (err.code === "EADDRINUSE") {
          reject(new Error(`Port ${this.port} is already in use`));
        } else {
          reject(err);
        }
      });
      this.server.listen(this.port, "127.0.0.1", () => {
        console.log(`Proxy server listening on http://localhost:${this.port}`);
        resolve();
      });
    });
  }
  stop() {
    if (this.server) {
      this.server.close();
      this.server = null;
    }
  }
  async handleRequest(req, res) {
    console.log(`[Proxy] ${req.method} ${req.url}`);
    res.setHeader("Access-Control-Allow-Origin", "*");
    res.setHeader("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS");
    res.setHeader("Access-Control-Allow-Headers", "*");
    res.setHeader("Access-Control-Max-Age", "86400");
    if (req.method === "OPTIONS") {
      console.log("[Proxy] Handling OPTIONS preflight");
      res.writeHead(204);
      res.end();
      return;
    }
    const url = new URL(req.url || "/", `http://localhost:${this.port}`);
    const path = url.pathname;
    if (path === "/v1/models" && req.method === "GET") {
      console.log("[Proxy] Handling /v1/models");
      await this.handleModels(res);
    } else if (path === "/v1/chat/completions" && req.method === "POST") {
      console.log("[Proxy] Handling /v1/chat/completions");
      await this.handleChatCompletions(req, res);
    } else {
      console.log(`[Proxy] 404 Not found: ${path}`);
      this.sendError(res, 404, "Not found");
    }
  }
  async handleModels(res) {
    const models = AVAILABLE_MODELS.map((m) => ({
      id: m.id,
      object: "model",
      created: Math.floor(Date.now() / 1e3),
      owned_by: "google",
      permission: [],
      root: m.id,
      parent: null
    }));
    res.writeHead(200, { "Content-Type": "application/json" });
    res.end(JSON.stringify({ object: "list", data: models }));
  }
  async handleChatCompletions(req, res) {
    var _a;
    console.log("[Proxy] Reading request body...");
    const body = await this.readBody(req);
    console.log("[Proxy] Request body length:", body.length);
    let request2;
    try {
      request2 = JSON.parse(body);
      console.log("[Proxy] Parsed request, model:", request2.model, "streaming:", request2.stream);
    } catch (e) {
      console.error("[Proxy] Invalid JSON body");
      this.sendError(res, 400, "Invalid JSON body");
      return;
    }
    const isStreaming = request2.stream === true;
    console.log("[Proxy] Executing with retry...");
    const result = await this.resilienceEngine.executeWithRetry(
      async (account) => {
        console.log("[Proxy] Making request with account:", account.email);
        return this.makeAntigravityRequest(account, request2, isStreaming, res);
      }
    );
    console.log("[Proxy] Result:", result.success, result.statusCode);
    if (!result.success && !isStreaming) {
      this.sendError(res, result.statusCode || 500, ((_a = result.error) == null ? void 0 : _a.message) || "Request failed");
    }
  }
  async makeAntigravityRequest(account, request2, isStreaming, res) {
    const antigravityRequest = this.requestTransformer.transformToAntigravity(request2, account.projectId);
    const headers = this.requestTransformer.getHeaders(account.accessToken, isStreaming);
    const endpoint = ANTIGRAVITY_CONFIG.endpoints.daily;
    const apiPath = isStreaming ? ANTIGRAVITY_CONFIG.paths.stream : ANTIGRAVITY_CONFIG.paths.generate;
    return new Promise((resolve) => {
      const url = new URL(`${endpoint}${apiPath}`);
      const body = JSON.stringify(antigravityRequest);
      console.log("[Proxy] Making HTTPS request to:", url.hostname, url.pathname);
      const options = {
        hostname: url.hostname,
        port: 443,
        path: url.pathname + url.search,
        method: "POST",
        headers: {
          ...headers,
          "Content-Length": Buffer.byteLength(body)
        }
      };
      const apiReq = https.request(options, (apiRes) => {
        console.log("[Proxy] API response status:", apiRes.statusCode);
        if (apiRes.statusCode === 429) {
          let errorText = "";
          apiRes.on("data", (chunk) => errorText += chunk);
          apiRes.on("end", () => {
            resolve({
              success: false,
              statusCode: 429,
              retryAfter: this.resilienceEngine.parseRetryAfter(errorText),
              error: new Error("Rate limited")
            });
          });
          return;
        }
        if (apiRes.statusCode && apiRes.statusCode >= 400) {
          let errorText = "";
          apiRes.on("data", (chunk) => errorText += chunk);
          apiRes.on("end", () => {
            console.error("[Proxy] API error response:", apiRes.statusCode, errorText.substring(0, 500));
            resolve({
              success: false,
              statusCode: apiRes.statusCode || 500,
              error: new Error(errorText)
            });
          });
          return;
        }
        if (isStreaming) {
          this.handleNodeStreamingResponse(apiRes, request2.model, res);
          resolve({ success: true, data: null });
        } else {
          let responseData = "";
          apiRes.on("data", (chunk) => responseData += chunk);
          apiRes.on("end", () => {
            try {
              const data = JSON.parse(responseData);
              const transformed = this.responseTransformer.transformFromAntigravity(data, request2.model);
              res.writeHead(200, { "Content-Type": "application/json" });
              res.end(JSON.stringify(transformed));
              resolve({ success: true, data: null });
            } catch (e) {
              resolve({
                success: false,
                statusCode: 500,
                error: new Error("Failed to parse response")
              });
            }
          });
        }
      });
      apiReq.on("error", (error) => {
        console.error("[Proxy] HTTPS request error:", error);
        resolve({
          success: false,
          statusCode: 500,
          error
        });
      });
      apiReq.write(body);
      apiReq.end();
    });
  }
  handleNodeStreamingResponse(apiRes, model, res) {
    res.writeHead(200, {
      "Content-Type": "text/event-stream",
      "Cache-Control": "no-cache",
      "Connection": "keep-alive"
    });
    let buffer = "";
    let chunkIndex = 0;
    apiRes.on("data", (chunk) => {
      buffer += chunk.toString();
      const lines = buffer.split("\n");
      buffer = lines.pop() || "";
      for (const line of lines) {
        const trimmed = line.trim();
        if (!trimmed || !trimmed.startsWith("data:")) continue;
        const transformedChunk = this.responseTransformer.transformStreamChunk(trimmed, model, chunkIndex);
        if (transformedChunk) {
          res.write(this.responseTransformer.formatSSEChunk(transformedChunk));
          chunkIndex++;
        }
      }
    });
    apiRes.on("end", () => {
      res.write(this.responseTransformer.formatSSEDone());
      res.end();
    });
    apiRes.on("error", (err) => {
      console.error("Streaming error:", err);
      res.end();
    });
  }
  async readBody(req) {
    return new Promise((resolve, reject) => {
      let body = "";
      req.on("data", (chunk) => body += chunk);
      req.on("end", () => resolve(body));
      req.on("error", reject);
    });
  }
  sendError(res, statusCode, message) {
    res.writeHead(statusCode, { "Content-Type": "application/json" });
    res.end(JSON.stringify({
      error: {
        message,
        type: "api_error",
        code: statusCode
      }
    }));
  }
};

// src/ui/SettingsTab.ts
var import_obsidian = require("obsidian");
var AntigravitySettingsTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin, settings, callbacks) {
    super(app, plugin);
    this.settings = settings;
    this.callbacks = callbacks;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h1", { text: "Antigravity Auth Settings" });
    this.createProxyStatusSection(containerEl);
    this.createAccountsSection(containerEl);
    this.createSettingsSection(containerEl);
  }
  createProxyStatusSection(containerEl) {
    const status = this.callbacks.getProxyStatus();
    containerEl.createEl("h2", { text: "Proxy Status" });
    const statusContainer = containerEl.createDiv({ cls: "proxy-status-container" });
    const indicator = statusContainer.createSpan({
      cls: `status-indicator ${status.running ? "status-active" : "status-inactive"}`
    });
    indicator.style.cssText = `
      display: inline-block;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background-color: ${status.running ? "#4caf50" : "#f44336"};
      margin-right: 8px;
    `;
    statusContainer.createSpan({
      text: status.running ? `Running on http://localhost:${status.port}/v1` : "Not running"
    });
    if (status.running) {
      const copyBtn = containerEl.createEl("button", { text: "Copy Endpoint URL" });
      copyBtn.style.marginLeft = "10px";
      copyBtn.onclick = () => {
        navigator.clipboard.writeText(`http://localhost:${status.port}/v1`);
        new import_obsidian.Notice("Endpoint URL copied to clipboard!");
      };
    }
  }
  createAccountsSection(containerEl) {
    containerEl.createEl("h2", { text: "Google Accounts" });
    const accounts = this.callbacks.getAccounts();
    if (accounts.length === 0) {
      containerEl.createEl("p", {
        text: "No accounts configured. Add an account to start using Antigravity."
      });
    } else {
      const accountList = containerEl.createDiv({ cls: "account-list" });
      for (const account of accounts) {
        const accountItem = accountList.createDiv({ cls: "account-item" });
        accountItem.style.cssText = `
          display: flex;
          align-items: center;
          justify-content: space-between;
          padding: 10px;
          margin: 5px 0;
          background: var(--background-secondary);
          border-radius: 5px;
        `;
        const leftSide = accountItem.createDiv();
        const statusColor = this.getStatusColor(account.status);
        const statusDot = leftSide.createSpan();
        statusDot.style.cssText = `
          display: inline-block;
          width: 8px;
          height: 8px;
          border-radius: 50%;
          background-color: ${statusColor};
          margin-right: 8px;
        `;
        leftSide.createSpan({ text: account.email });
        const statusText = leftSide.createSpan({
          text: ` (${this.getStatusText(account)})`,
          cls: "account-status"
        });
        statusText.style.cssText = "color: var(--text-muted); font-size: 0.9em; margin-left: 8px;";
        const removeBtn = accountItem.createEl("button", { text: "Remove" });
        removeBtn.onclick = () => {
          this.callbacks.onRemoveAccount(account.email);
          this.display();
        };
      }
    }
    const addBtn = containerEl.createEl("button", {
      text: "+ Add Google Account",
      cls: "mod-cta"
    });
    addBtn.style.marginTop = "10px";
    addBtn.onclick = async () => {
      try {
        await this.callbacks.onLogin();
        this.display();
        new import_obsidian.Notice("Account added successfully!");
      } catch (error) {
        new import_obsidian.Notice(`Login failed: ${error.message}`);
      }
    };
  }
  createSettingsSection(containerEl) {
    containerEl.createEl("h2", { text: "Configuration" });
    new import_obsidian.Setting(containerEl).setName("Proxy Port").setDesc("Port for the local OpenAI-compatible proxy server").addText((text) => text.setPlaceholder("8787").setValue(String(this.settings.proxyPort)).onChange(async (value) => {
      const port = parseInt(value) || 8787;
      this.settings.proxyPort = port;
      await this.callbacks.onSettingsChange(this.settings);
    }));
    containerEl.createEl("h3", { text: "Available Models" });
    const modelTable = containerEl.createEl("table");
    modelTable.style.cssText = "width: 100%; border-collapse: collapse; margin-bottom: 15px; font-size: 0.9em;";
    const headerRow = modelTable.createEl("tr");
    headerRow.createEl("th", { text: "Model ID (use in Copilot)" }).style.cssText = "text-align: left; padding: 5px; border-bottom: 1px solid var(--background-modifier-border);";
    headerRow.createEl("th", { text: "Description" }).style.cssText = "text-align: left; padding: 5px; border-bottom: 1px solid var(--background-modifier-border);";
    for (const model of AVAILABLE_MODELS) {
      const row = modelTable.createEl("tr");
      const idCell = row.createEl("td");
      idCell.style.cssText = "padding: 4px 5px; font-family: monospace; font-size: 0.85em;";
      const code = idCell.createEl("code", { text: model.id });
      code.style.cssText = "background: var(--background-secondary); padding: 2px 5px; border-radius: 3px; cursor: pointer;";
      code.onclick = () => {
        navigator.clipboard.writeText(model.id);
        new import_obsidian.Notice(`Copied: ${model.id}`);
      };
      row.createEl("td", { text: model.name }).style.cssText = "padding: 4px 5px;";
    }
    new import_obsidian.Setting(containerEl).setName("Auto-start Proxy").setDesc("Automatically start the proxy when Obsidian loads").addToggle((toggle) => toggle.setValue(this.settings.autoStartProxy).onChange(async (value) => {
      this.settings.autoStartProxy = value;
      await this.callbacks.onSettingsChange(this.settings);
    }));
    new import_obsidian.Setting(containerEl).setName("Enable Logging").setDesc("Log requests and responses for debugging").addToggle((toggle) => toggle.setValue(this.settings.enableLogging).onChange(async (value) => {
      this.settings.enableLogging = value;
      await this.callbacks.onSettingsChange(this.settings);
    }));
    new import_obsidian.Setting(containerEl).setName("Max Retries").setDesc("Maximum number of retry attempts on rate limit").addSlider((slider) => slider.setLimits(1, 10, 1).setValue(this.settings.maxRetries).setDynamicTooltip().onChange(async (value) => {
      this.settings.maxRetries = value;
      await this.callbacks.onSettingsChange(this.settings);
    }));
    containerEl.createEl("h2", { text: "Usage with Obsidian Copilot" });
    const instructions = containerEl.createDiv({ cls: "instructions" });
    instructions.innerHTML = `
      <ol>
        <li>Install and enable the Obsidian Copilot plugin</li>
        <li>Go to Copilot settings \u2192 Model section</li>
        <li>Set "API Base URL" to: <code>http://localhost:${this.settings.proxyPort}/v1</code></li>
        <li>Set "API Key" to any value (e.g., "unused")</li>
        <li>Select one of the Antigravity models</li>
      </ol>
    `;
  }
  getStatusColor(status) {
    switch (status) {
      case "active":
        return "#4caf50";
      case "rate_limited":
        return "#ff9800";
      case "expired":
        return "#f44336";
      case "error":
        return "#f44336";
      default:
        return "#9e9e9e";
    }
  }
  getStatusText(account) {
    switch (account.status) {
      case "active":
        return "Active";
      case "rate_limited":
        if (account.rateLimitExpiry) {
          const remaining = Math.ceil((account.rateLimitExpiry - Date.now()) / 1e3);
          return `Rate limited (${remaining}s)`;
        }
        return "Rate limited";
      case "expired":
        return "Token expired";
      case "error":
        return "Error";
      default:
        return account.status;
    }
  }
  updateSettings(settings) {
    this.settings = settings;
  }
  refresh() {
    this.display();
  }
};

// src/main.ts
var AntigravityAuthPlugin = class extends import_obsidian2.Plugin {
  constructor() {
    super(...arguments);
    this.settings = DEFAULT_SETTINGS;
    this.proxyRunning = false;
  }
  async onload() {
    console.log("Loading Antigravity Auth Plugin");
    const data = await this.loadPluginData();
    this.accountManager = new AccountManager(
      async (accounts) => {
        await this.savePluginData({ settings: this.settings, accounts });
      },
      this.settings.oauthClientId,
      this.settings.oauthClientSecret
    );
    this.oauthManager = new OAuthManager(
      this.settings.oauthClientId,
      this.settings.oauthClientSecret
    );
    this.proxyServer = new ProxyServer(this.accountManager, this.settings.proxyPort);
    if (data == null ? void 0 : data.accounts) {
      await this.accountManager.loadAccounts(data.accounts);
    }
    const callbacks = {
      onLogin: () => this.performLogin(),
      onRemoveAccount: (email) => this.removeAccount(email),
      onSettingsChange: (settings) => this.updateSettings(settings),
      getAccounts: () => this.accountManager.getAccounts(),
      getProxyStatus: () => ({ running: this.proxyRunning, port: this.settings.proxyPort })
    };
    this.settingsTab = new AntigravitySettingsTab(
      this.app,
      this,
      this.settings,
      callbacks
    );
    this.addSettingTab(this.settingsTab);
    this.addCommand({
      id: "start-proxy",
      name: "Start Proxy Server",
      callback: () => this.startProxy()
    });
    this.addCommand({
      id: "stop-proxy",
      name: "Stop Proxy Server",
      callback: () => this.stopProxy()
    });
    this.addCommand({
      id: "add-account",
      name: "Add Google Account",
      callback: () => this.performLogin()
    });
    if (this.settings.autoStartProxy && this.accountManager.getAccounts().length > 0) {
      await this.startProxy();
    }
  }
  async onunload() {
    console.log("Unloading Antigravity Auth Plugin");
    this.stopProxy();
    this.accountManager.dispose();
    this.oauthManager.stopCallbackServer();
  }
  async loadPluginData() {
    const data = await this.loadData();
    if (data) {
      const mergedSettings = { ...DEFAULT_SETTINGS, ...data.settings };
      if (!mergedSettings.oauthClientId || mergedSettings.oauthClientId.trim() === "") {
        mergedSettings.oauthClientId = DEFAULT_SETTINGS.oauthClientId;
      }
      if (!mergedSettings.oauthClientSecret || mergedSettings.oauthClientSecret.trim() === "") {
        mergedSettings.oauthClientSecret = DEFAULT_SETTINGS.oauthClientSecret;
      }
      this.settings = mergedSettings;
      return data;
    }
    return null;
  }
  async savePluginData(data) {
    await this.saveData(data);
  }
  async performLogin() {
    try {
      new import_obsidian2.Notice("Opening Google login...");
      const account = await this.oauthManager.performFullLogin();
      console.log("OAuth login successful, adding account:", account.email);
      this.accountManager.addAccount(account);
      new import_obsidian2.Notice(`Successfully added account: ${account.email}`);
      this.settingsTab.refresh();
      if (!this.proxyRunning && this.settings.autoStartProxy) {
        await this.startProxy();
        this.settingsTab.refresh();
      }
    } catch (error) {
      console.error("Login failed:", error);
      new import_obsidian2.Notice(`Login failed: ${error.message}`);
    }
  }
  removeAccount(email) {
    this.accountManager.removeAccount(email);
    new import_obsidian2.Notice(`Removed account: ${email}`);
    if (this.accountManager.getAccounts().length === 0) {
      this.stopProxy();
    }
  }
  async updateSettings(settings) {
    const portChanged = settings.proxyPort !== this.settings.proxyPort;
    const credentialsChanged = settings.oauthClientId !== this.settings.oauthClientId || settings.oauthClientSecret !== this.settings.oauthClientSecret;
    this.settings = settings;
    this.settingsTab.updateSettings(settings);
    await this.savePluginData({
      settings: this.settings,
      accounts: this.accountManager.getAccounts()
    });
    if (credentialsChanged) {
      const clientId = settings.oauthClientId || DEFAULT_SETTINGS.oauthClientId;
      const clientSecret = settings.oauthClientSecret || DEFAULT_SETTINGS.oauthClientSecret;
      this.oauthManager = new OAuthManager(clientId, clientSecret);
    }
    if (portChanged && this.proxyRunning) {
      await this.stopProxy();
      await this.startProxy();
    }
  }
  async startProxy() {
    if (this.proxyRunning) {
      new import_obsidian2.Notice("Proxy is already running");
      return;
    }
    if (this.accountManager.getAccounts().length === 0) {
      new import_obsidian2.Notice("Please add a Google account first");
      return;
    }
    try {
      this.proxyServer = new ProxyServer(this.accountManager, this.settings.proxyPort);
      await this.proxyServer.start();
      this.proxyRunning = true;
      new import_obsidian2.Notice(`Proxy started on http://localhost:${this.settings.proxyPort}/v1`);
    } catch (error) {
      console.error("Failed to start proxy:", error);
      new import_obsidian2.Notice(`Failed to start proxy: ${error.message}`);
    }
  }
  stopProxy() {
    if (!this.proxyRunning) return;
    this.proxyServer.stop();
    this.proxyRunning = false;
    new import_obsidian2.Notice("Proxy server stopped");
  }
};
